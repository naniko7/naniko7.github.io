[{"title":"chap1 C++简介","url":"/2022/05/29/chap1-c-primer/","content":"C++的特点：\n\n继承了C语言的高效、简洁、快速和可移植性的传统。\n面向对象编程（OOP）\nC++的模板特性提供了另一种全新的编程方法：泛型编程\n\nc++头文件的参考文档：标准库头文件  - C++中文 - API参考文档 (apiref.com)\n1. C++简史1.1 一些词汇和基本知识结构化编程时代：C 、Pascal\nOPP: C++ 、SmallTalk\n操作系统：管理计算机资源、处理计算机与用户之间交互的一组程序。\n【Note1】\n需求：为此需要一种语言能够生成程序并有效地控制硬件。\n【Note2】\n难点：汇编语言迁移性差。\n\n传统上使用汇编语言满足操作系统的相应操作。\n汇编语言：低级语言，直接操作硬件，如直接访问CPU寄存器和内存单元。\n汇编语言针对特定的计算机处理器，迁移性差。\n\n\n\n【Note3】：\n解决方案：编译器 + 高级语言\n\n编译器作用：将高级语言翻译成特定计算机的内部语言。\n\n1.2 面向过程与面向对象程序 &#x3D; 数据 + 算法\nC语言（强调算法）\n\n过程性语言：过程化编程首先要确定计算机应采取的操作，然后使用编程语言来实现这些操作。即先固定流程，根据流程得到结果。\n结构化编程：例如采用for循环、while循环结构来将指令限制为行为良好的结构，避免执行路径混乱。\n自顶向下（top-down）的设计：将大型程序分解为小型、便于管理的任务。使用函数来表示各个任务模块。\n\n结构化编程技术反应了过程性编程思想，根据执行的操作来构思程序。\nC++语言（强调数据）\n\nOPP：试图让语言满足问题的要求。其理念是设计与问题的本质特性相对应的数据格式。\n类与对象\n类表示程序需要处理的东西，定义好可执行的操作。\n\n\n泛型编程\n使重用代码和抽象通用概念的技术更加简单。\n强调独立于特定数据类型，可以编写一个不是特定类型的函数。\n\n\n\n优点：可以方便地重用和修改现有的、经过仔细测试的代码。\nC给了C++联系硬件的能力，OPP给了C++高级抽象的能力。\n1.3 编程步骤\n源代码\n编译器编译得到目标代码\n链接程序（链接目标代码、启动代码与库代码）\n可执行代码\n\n源代码\n\n常见的扩展名：C、cc、cxx、c++、cpp\n\n编译器\n\n编译器、编辑器与IDE之间的区分\n\n","categories":["C++"],"tags":["C++"]},{"title":"chap3 C++数据类型","url":"/2022/06/01/chap3-c-primer/","content":"本章的内容：\n\nC++基本数据类型分别介绍（不包括复合类型）\nC++运算\nC++类型转换\n\n前置补充知识编码知识：程序员必备：彻底弄懂常见的7种中文字符编码 - 知乎 (zhihu.com)\n1. C++的数据类型C++的基本类型分为两组：整型与浮点型。\n整型：存储为整数的值组成。整型包括：\n\n布尔型：bool\n字符型：char、signed char、unsigned char\nshort、unsigned short\nint、unsigned int\nlong、unsigned long\nlong long、unsigned long long\n\n浮点型：存储为浮点格式的值组成。\n\nfloat\ndouble\nlong double\n\n1.1 变量\n变量名的命名规则有哪些？\n\n不要以数字开头\n避免以下划线开头的变量名称：该类变量名是保留给实现使用的（意思是说在源代码在编译之后会产生的名字，比如main()函数经过编译之后变成_main()，如果自定义命名为 _main()就会导致冲突。要么无法编译，要么编译成功但是崩溃，总之会带来极强的不确定性）\nC++对大小写敏感，数据类型不可以大写，比如int不可以写为Int\n不能用C++的关键字用作名称\n有的平台对变量名称的长度有限制\n\n\n变量的初始化方式\n   //C++和C都有   int oo = 23;   //C++有   int oo(23);   //C++11中允许使用&#123;&#125;对任意类型的数据进行初始化，等号是可选的   int oo = &#123;23&#125;;   int oo&#123;23&#125;;3. ### 1.2 整型**基本术语*** 宽度（width）：用于描述存储整数时使用的内存量。* 位（bit）：计算机内存的基本单位。* 字节（byte）：通常指的是8位的内存单元。  * C++的字节一般包含8位，但对于Unicode这样的字符集来说需要使用16位的字节。  * 字节的含义取决于操作系统，同一个类型，int在系统一中可能为16位，系统二中则为32位。    * 如何查看某个类型的字节数？      答：使用sizeof()函数    * 如何知道某个类型的存储范围？      答：寻找类似climits的头文件，其中定义了诸如CHAR_BIT、CHAR_MAX等的值。**short、unsigned short*** 至少16位：有符号的16位表示范围[-32768,32767]* unsiged short 16位范围为：[0,65535]**int、unsigned int*** 至少与short一样长* 可以更长，32位也是可以的**long、unsigned long*** 至少32位* 至少与int一样长**long long、unsigned long long*** 至少64位* 至少与long一样长**usigned char、char、wcha_t、char16_t、char32_t*** char类型用于存储字符和小整数（单个数字，如-1、1、9等）* C++对字符使用单引号，对字符串使用双引号，使用的不同将会导致cout对象的不同行为* 使用语句char a;时，在默认情况下char既不是有符号也不是无符号。* wcha_t：有足够的空间，可以表示系统使用的最大扩展字符集。并不适用使用cin cout而是使用wcin和wcout对象处理该种类型的消息。* char16_t：16位，无符号，使用前缀&quot;u&quot;表示。* char32_t：32位，无符号，使用前缀“U”表示。  ```c++  //16位表示字符和字符串  char16_t ch = u&#x27;a&#x27;;  char16_t ch = u&quot;a&quot;;  //32位表示字符和字符串  char32_t ch = U&#x27;a&#x27;;  char32_t ch = U&quot;a&quot;;  ```**bool类型*** true和flase都可以通过提升转换为int类型  * 把char、unsigned char、short、unsigned short转换成int类型称为类型提升(promotion）  * 任何数字和指针都可以被隐式转换为bool值**const限定符*** 作用：创建常量，该常量需要被多次在同一个地方使用* 创建方式：  ~~~c++  const type name = value;\n\n\n注意：const在声明时就必须指明value值。\n\n好处：\n\n使用C++的作用域规则将其定义在特定的函数或文件中\nconst可以用于各种复杂的类型\n\n\n\n【Notes】\n\nC++不保证符号整型超越限制时不出错，不会纠正上溢和下溢时的错误。编译器爱怎么来怎么来了。\n整型的自然长度是指处理起来效率最高的长度，如果没有充足理由选择其他类型，那就选int。\n进制：\n8进制：前面是“0”\n16进制：前面是“0x”或者“0X”\n\n\n转义字符：比如字符串里面还需要使用双引号，就使用&#x2F;“\n换行：&#x2F;n\n退格：&#x2F;b\n引号：&#x2F;‘   &#x2F;“\n\n\n\n\n1.3 浮点型疑问及解答\nchar类型占用几个字节？char类型可以存储汉字吗？\n答：使用sizeof()函数测试，char类型包含一个字节，不能存储汉字。下面介绍一些编码知识。\n\n字符编码：计算机所读取的符号都是由0和1组成的，每个符号需要有一个对应的编码以便计算机识别。\n常见的编码：\nASCII编码：标准的ASCII编码只有128个字符，使用一个字节就能表示，但是该编码显然无法表示汉字。\n一些中文编码：\nGB2312（2个字节，兼容ASCII，是全角输入法，例如2在半角输入下是1字节，全角输入下就是2字节，一共只有6763个汉字）\nGBK（2字节，2字节最多能表示6w+字符，但是为了保证和ASCII兼容）\nGB18030(使用4字节)\n\n\nUTF-8：\nUnicode为每个字符分配了唯一的编码，但是没有告诉如何存储。utf-8解决了这一问题。\n不同的符号所需的字节不一样，例如汉字就需要3个字节。\n\n\n\n\n\n\n啊\n\n\n","categories":["C++"],"tags":["C++ primer"]},{"title":"chap2 C++程序框架说明","url":"/2022/05/29/chap2-c-primer/","content":"最重要的部分为每章后的总结，需要仔细查阅\n本章内容：\n\n一个C++程序的必要部分解释：例如编译指令、头文件等\nC++语句介绍及函数介绍\n\n1. C++程序各部分说明\n注释： &#x2F;&#x2F;\n\n#include ：预处理器编译指令，用于包含头文件\n\n#include &lt;iostream&gt;\n// 该行预处理器编译指令等同于：将iostream文件的内容取代程序中的代码行#include &lt;iostream&gt;。原文件并没有被修改，而是将源代码文件与iostream文件组合成一个复合文件\n\n\n程序编译时自动执行\n\n头文件：每个头文件支持一组工具，被包含在其他文件中，也可以称为包含文件\n\n以.h结尾：C++与C的旧式风格，C与C++均可以使用\n没有扩展名：C++可以使用\n以c开头：转换后的C，可以使用一些不是C的特性，如namespace\n\n\n\n\nint main( )：函数头\n\n接口：这里可以理解为操作系统与之的接口\n\n\nusing namespace：编译指令\n\nusing：编译指令\nusing namespace std;// 该编译命令使得std名称空间中的所有名称都可以用//如果不想包含所有的代码，只想用某个函数，只需要编译特定的需要的对象就好//例如只需要使用cout对象，仅编译cout即可using std::cout// 采用以上方式后，\n\n\n\nnamespace\n\n\n\n\n1.1 main函数函数 &#x3D; 函数头 + 函数体\nint main()&#123;    cout &lt;&lt; &quot;this is a sentence&quot;;    cin.get();    cin.get();    return 0;&#125;\n\n1.1.1 函数头函数头 &#x3D; 接口\nint main()\n\n\nint：函数返回类型。描述的是从函数返回给调用它的函数的信息。\nmain：函数名\n()：这里面可以填写参数，称作形参列表或参数列表（argument list或parameter list）\n\n函数头的书写注意事项：\n\n指定函数返回类型（如int，此后函数体内需要包含return 0语句），可以使用void类型，但是有些系统上不能工作，最好不用。\n传入的参数可以指定为void，表示无需传入参数\n\n1.1.2 函数体&#123;    cout &lt;&lt; &quot;this is a sentence&quot;;    cin.get();    cin.get();    return 0;&#125;\n\n\n语句以分号结束，不可省略\n结束函数\n\n1.1.3 main()函数要求\n必须有main()函数，动态链接库（DLL）除外。\n如果编译器到达main()函数末尾没有返回语句，默认以return 0 语句结尾。但是这种隐含的返回语句只适用于main()函数\n\n1.2 名称空间\n头文件（包含文件）：支持一组特定的工具\n\n在C语言中，头文件使用扩展名h（C++中还可以用这种文件）\nC++头文件没有扩展名，没有h的头文件也可以包含名称空间\n\n\n名称空间\n\n组织程序，防止同名的函数使用混乱（类似于事先分配好地方，每个函数在自己的地方活动）\n\n以iostream为例\n\n偷懒做法\nusing namespace std;\n\n用什么写什么\nusing std::cout;\n\n此后无需使用std::cout，只需要使用cout\n\n\n\n\n\n\n1.3 重载运算符等\n什么叫重载运算符？\n通过重载，同一个运算符将有不同的含义。\n例如，&amp;既可以表示地址运算符，又能表示AND运算符\n\n\n控制符、换行符等\n控制符：例如endl（需要引入iostream，直接使用需要引入名称空间std）\n换行符\n\n\n\n1.4 使用Vscode书写C++程序\n根据报错信息下载对应的插件\n一些符号说明\n控制符”endl”\n用处：重启一行\n\n\n换行符“\\n”\n用处：换行\n是一种转义序列\n\n\n\n\n\n2. C++语句常见的语句类型：\n\n声明语句（定义声明）\n赋值语句\n\n2.1 语句声明语句\nint carrots;\n\n以上语句声明了一个类型为int的名为carrots的变量。\n\n声明语句的作用：分配内存与确定类型。\nC++中所有的变量都必须声明，避免在不知情情况下创建一个新的变量。\n在首次使用变量之前声明即可，无需在最开始声明全部变量。\n\n赋值语句\ncarrots = 25;//将25赋值给carrots变量int rabbits, apples;rabbits = apples = carrots;//C++允许连续使用赋值运算符，赋值从右到左进行int a = 33;//c++允许在创建变量时就对他赋值\n\n2.2 函数\nC++的函数分为两种：有返回值的和没有返回值的。\n\n几个概念：\n\n\n\n调用函数\n\n最外层的接口函数\n\n\n函数调用\n\n被调用的函数\n\n\n\nC++程序应当为程序中使用的每个函数提供原型。函数原型之于函数就像变量声明之于变量，即指出涉及的类型，在使用某个函数前，必须提供原型。\n\n\n函数原型怎么提供？\n\n方法一：在源代码文件中输入函数原型。 \n方法二：包含定义了原型的头文件。\n\n\n原型只描述了函数的接口，定义的时发送给函数的信息和返回的信息，不包含函数实现的代码。\n\n推荐写法：\n\n在开头提供自定义函数原型\n\n书写main函数\n\n书写其他自定义的函数\n#include &lt;iostream&gt;using namespace std;//函数原型int addfunction(int,int);//书写main函数int main()&#123;    int a = 2;    int b = 3;    int c;    c = addfunction(a,b);    return 0;&#125;//定义addfunctionint addfunction(int a,int b)&#123;    int c;    c = a + b ;    return c;&#125;\n\n\n\n疑问记录及回答\n如何理解using namespace std？ 这里的std可以自定义名称吗？ std指向的代码部分是那些？ 哪些函数可用，如何查看？\n答：\n\nusing namespace std是编译指令，指向std名称空间中的代码。\nstd是专用的名称，目前尚不清楚这个命名机制，但是尝试改为using namespace ss后程序不可执行\n\n\n\n计算机对数据的存储。例如int a &#x3D; 25;对于变量a来说，在计算机中是如何存储的？\n答：\n\nchar类型可以存储什么？\n答：char类型占用1个字节（8位），可以存储字符和小整数。参照：(54条消息) 贝贝有疑：char为什么能存两个字节，却只能存一个字符？_HappyMouse丨贝贝的博客-CSDN博客_char为什么占两个字节\n但是这篇博客里面说的是占用2个字节，使用sizeof(char)输出看到为1个字节。参考：\n[谁跟我说说在C，C++，JAVA中int,char,各占几个字节好么_百度知道 (baidu.com)](https://zhidao.baidu.com/question/405477895.html#:~:text=C%2FC%2B%2B，char是单字符数据类型，只占1个字节。 Java中，内码（运行内存）的char使用UTF16的方式编码，一个char占用两个字节，但是某些字符需要两个char来表示。,所以，一个字符会占用2个或4个字节。 Java中，外码中char使用UTF8的方式编码，一个字符占用1～6个字节。)\n\n既然有8位，那为什么不能存储125这样的数字呢？\n解释：char类型存储的是字符，一个字符就占用2个字节。\nchar a = &#x27;125&#x27;;//对以上语句来说，1、2、5都分别为一个字符，共三个字符//尝试输出acout &lt;&lt; a;// 输出结果为5，只会输出最后那个字符\n\n举例说明？\nchar a = &#x27;65&#x27;;//输出为A，为65对应的ASCII码char b = 65;//超限，输出为最后一个字符5\n\n\n\n总结\nC与C++的异同。\n【Notes】\n\nC使用printf函数时需要指定打印类型，而C++中使用cout函数可以自主判断变量的类型选择输出。其逻辑为：\n\n\nC++的特性。\n\n名称空间支持：编写大型程序或组合现有代码时更为容易。将某部分代码封装在一个叫做名称空间的单元中，这样就可以指定该部分代码属于什么来源。\n\n\n\n\n","categories":["C++"],"tags":["C++ primer"]},{"title":"ssh-github连接","url":"/2022/05/19/ssh-github%E8%BF%9E%E6%8E%A5/","content":"SSH连接GitHub问题说明：尝试使用hexo和GitHub搭建个人博客时，不少教程介绍使用时，需要创建SSH公匙用于与GitHub连接，几次尝试连接GitHub均失败。本篇博客用于记录尝试过程。\n目的：使用SSH连接Github\n参考资料（利用Hexo搭建博客，但是按照步骤来在ssh连接时遇到了困难）：超详细 Hexo + Github Pages 博客搭建教程 - 知乎 (zhihu.com)\n前置：\n\n已完成用户名、邮箱配置，并生成了ssh密钥文件。且在GitHub-settings-keys页面中，创建了新的SSH Key，完成了id_rsa.pub的内容复制。\n完成了Node.js，git的安装\n\n报错信息：\n在执行下方命令时，出现报错。\n\n$ ssh -T git@github.comssh: connect to host ssh.github.com port 22: Connection timed out\n\n尝试解决方法：\n在.ssh文件夹下新建config文件，添加如下信息。\nHost github.comUser gitHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443\n\n效果：\n\n无用，端口443依然连接超时。\n\n在“C盘&#x2F;用户&#x2F;用户名”文件夹下生成了.gitconfig文件，其中记录了已经和git绑定的GitHub账号，内容为：\n[user]\tname = naniko7\temail = 937489834@qq.com[color]\tui = auto\n\n\n放弃ssh，使用http进行连接，不再使用ssh连接。\n\n\n​       配置代理的端口，此处不要设置为1080，看看自己的vpn的端口号是什么，如clash的端口号为7890，则将端口设为7890。之后就能通过http的方式进行git clone等操作。\n参考资料：【经验宝宝】Failed to connect to github.com port 443: Operation timed out - 烟霞志 (simplestark.com)\ngit config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy http://127.0.0.1:7890\n\n\n可以看到http方式已经可以正常clone，但是ssh依然不行。\n","categories":["other","hexo"]},{"title":"try tag_plugins&assets","url":"/2022/05/18/try-tag-plugins-assets/","content":"_.compactUnderscore.js_.compact([0, 1, false, 2, &#x27;&#x27;, 3]);=&gt; [1, 2, 3]\n\n\n\nimport base64import torchimport numpy a = numpy.array(5)\n\n\n\n\n\n\n\n\n"},{"title":"word vectors","url":"/2022/06/10/word-vectors/","content":"博文内容：\n\n斯坦福2021NLP课程关于词向量的介绍\nBert等词向量的补充\n\n1. 课程内容总结1.1 Word meaninghow to represent the meaning of words?\n\nWordNet： Use synonym sets and hypernyms\none-hot：orthogonal, miss the similarity\ndistributional semantics:  A word’s meaning is given by the words close-by\n\nWord2vec\n\nidea\ncorpus\ncenter word &amp; context word, obtain the word vectors\ncalculate similarity of the word vectors\nmaximize the probability\n\n\nnotion\nthere are two types of word vectors: c &amp; o, so which vectors be used for the representation of word?\nDo average. In fact, both of them are very similar. No much difference.\n\n\nwhat’s probability？\nP(o|c)\nc vector &amp; o vector &amp; softmax function\nmethod:\ncalculation the loss function\n\n\n\n\n\n\nloss function\nuse “log” to simplify the derivation\ngive a window [-m,m]\nsum all the loss of each word\n\n\n\n\nproblems\none word, but multiple meanings, can one vector be used in every occasion？\nactually，it can. And it works. Not too bad.\n\n\nhow about the adj, pron&amp;etc.?\ntalk about language models later\n\n\nno concern about the word position, calculate the probability only using the function, no position information.\n\n\n\n","categories":["NLP","Deep Learning"],"tags":["词向量","word2vec"]},{"title":"机器学习之决策树","url":"/2022/06/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/","content":""},{"title":"机器学习之感知机","url":"/2022/06/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%84%9F%E7%9F%A5%E6%9C%BA/","content":"博客内容：李航《统计学习方法》第二章感知机学习。\n衔接第一章，感知机初步总结：\n\n\n\n模型\n策略\n算法\n\n\n\n1. 非概率模型：求的不是联合分布，而是决策函数y &#x3D; f(x)，属于判别模型\n\n\n\n\n2. 二分类问题：X为实例输入的特征向量，Y是输出的类别，Y取值{1，-1}\n\n\n\n\n\n\n\n\n\n疑问\n什么叫独立同分布？怎么判断独立同分布？什么情况下可以假设变量满足独立同分布？\n\n","categories":["机器学习"],"tags":["机器学习","统计学习概论","感知机"]},{"title":"机器学习之统计学习概论","url":"/2022/06/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/","content":"博客内容 ：本文主要是对李航老师的《统计学习方法》的第一章的总结归纳。\n学习资料和参考资料索引：\n刘建平老师博客：\n0081. 机器学习 - 随笔分类(第4页) - 刘建平Pinard - 博客园 (cnblogs.com)\n0081. 机器学习 - 随笔分类(第4页) - 刘建平Pinard - 博客园 (cnblogs.com)\n一个库：\nhangtwenty&#x2F;dive-into-machine-learning: Free ways to dive into machine learning with Python and Jupyter Notebook. Notebooks, courses, and other links. (First posted in 2016.) (github.com)\n李航老师书本答案：\n(58条消息) 李航老师统计学习方法答案汇总_六七～的博客-CSDN博客_统计学习方法答案\n1、统计学习1.1 统计学习简述\n基于数据构建模型，使用模型预测数据。\n统计学习也成为统计机器学习。\n研究对象：数据。获取数据的特征，抽取数据的模型，回归数据的分析与预测。\n方法\n监督学习\n无监督学习\n强化学习\n\n\n三要素\n模型：模型的假设空间（某个函数的集合）\n策略：模型的评价准则，用于选出最优模型\n算法：选出最优模型\n\n\n\n1.2 统计学习分类1.2.1 基本分类监督学习\n本质：学习输入到输出的映射的统计规律\n基础知识\n三个空间\n输入空间\n输出空间：可以看作特征空间\n特征空间：具体的输入是一个实例，由特征向量表示，特征向量存在的空间称为特征空间\n\n\n模型假设：输入数据与输出数据遵循联合概率分布。训练数据与测试数据被看作都是依照联合概率分布独立同分布产生的。\n假设空间：输入空间到输出空间的映射的集合\n可以是概率模型或者非概率模型\nP（y|x）\ny &#x3D; f(x)\n\n\n可用场景\n回归\n分类\n标注\n\n\n\n\n\n无监督学习\n描述：从无标注数据中学习预测模型的机器学习问题。\n训练模型：X是输入空间，Z是隐式结构空间\nz &#x3D; g(x)\nP(x|z)\nP(z|x)\n\n\n可用场景\n聚类\n降维\n概率估计\n\n\n\n强化学习\n本质：学习最优的序贯决策\n\n过程：\n\n系统从环境中观察到一个状态s和一个奖励r\n系统根据s和r采取一个动作a\n环境根据系统选择的动作决定下一步的状态和下一步的奖励\n\n\n相关参数：\n\n五元组&lt;S,A,P,r,y&gt;——用于确定状态和奖励\nS：状态。下一个状态只依赖于前一个状态和动作。\nA：动作。\nP：状态转移概率函数：由动作和状态预测下一个状态。\nr：奖励函数。下一个奖励只依赖前一个状态和动作。\ny：衰减系数\n\n\n策略Π——用于确定动作\n给定状态下动作的函数 a &#x3D; f(s)或者 P（a|s）。给定策略后，出现一个状态就能确定一个动作，即确定了系统与环境的互动行为。\n\n\n价值函数&#x2F;状态价值函数\n定义：策略Π从某一个状态s开始的长期累积奖励的数学期望\n关键：\n条件：状态s &#x3D; st\n奖励从rt+1开始计算\n\n\n\n\n动作价值函数\n定义：策略Π从某一个状态s和动作a开始长期累积奖励的数学期望\n关键：\n条件：状态s &#x3D; st ，动作a &#x3D; at\n\n\n\n\n\n\n学习目标：\n\n在所有可能的策略中选出价值函数最大的策略Π^*^\n\n\n方法：\n\n无模型方法：不直接学习模型\n基于策略：试图求解最优策略\n基于价值：试图求解最优价值函数，间接学到最优策略\n\n\n有模型方法\n直接学习马尔可夫决策过程的模型：状态转移概率函数P与奖励函数r\n\n\n\n\n\n【Notes】\n\n学习中往往从具体的策略出发，不断优化已有策略。\n\n半监督学习与主动学习半监督学习：\n\n少量标注数据和大量未标注数据\n\n主动学习：\n\n机器给出示例让教师标注，根据标注数据学习预测模型\n目标：找出对学习最有帮助的示例让教师标注，减小标注的代价。\n\n【Notes】\n\n监督学习是基于已经给定的标注数据，是随机的，而不是特定的选择的标注数据，可以看作是”被动学习“\n\n1.2.2 按模型分类概率模型与非概率模型监督学习\n\n概率模型：P（y|x）\n\n属于生成模型\n\n\n非概率模型：y &#x3D; f(x)\n\n属于判别模型\n\n\n\n无监督学习\n\n概率模型：P（z|x）或者P（x|z）\n非概率模型：z &#x3D; g(x)\n\n概率模型举例：决策树、朴素贝叶斯、隐马尔可夫模型、条件随机场、概率潜在语义分析、潜在狄利克雷分配、高斯混合模型\n非概率模型举例：感知机、支持向量机、k近邻、AdaBoost、k均值、潜在语义分析、神经网络\n【Notes】\n\nP(y|x)和y &#x3D; f(x)可以相互转化。条件概率分布最大化后得到函数，函数归一化后得到条件概率分布。\n概率模型和非概率模型区别不在于映射关系，在于模型的内在结构。\n概率模型一定可以表示为联合概率分布的形式，非概率模型不一定存在这样的联合概率分布\n\n\n概率模型代表：概率图模型。联合概率分布可以根据图的结构分解为因子乘积形式。\n\n线性模型与非线性模型\n非概率模型可以分为线性模型和非线性模型。如果y &#x3D; f(x)是线性函数，就是线性模型。\n\n线性模型举例：感知机、线性支持向量机、k近邻、k均值、潜在语义分析\n非线性模型举例：核函数支持向量机、AdaBoost、神经网络\n参数化模型与非参数化模型\n参数化模型：模型参数的维度固定\n非参数化模型：参数维度不固定或者无穷大，随着训练数据量增多而增大\n\n1.2.3 按算法分类在线学习\n每次接受一个样本，进行预测，学习模型，不断重复操作\n既可以是无监督学习也可以是监督学习，强化学习本身就是一种在线学习\n通常模型准确率低于批量学习，因为每次可以利用的数据有限。优点在于可以快速适应新的模式（此时就不满足独立同分布假设了）\n\n批量学习\n一些接受所有数据，学习模型，进行预测\n\n1.2.4 按技巧分类贝叶斯学习核方法1.3 统计学习方法三要素方法 &#x3D; 模型 + 策略 + 算法\n模型\n模型：所要学习的条件概率分布或者决策函数\n假设空间里包含所有可能的条件概率分布或者决策函数\n假设空间为决策函数的集合\n\n\n\n策略一些名词概念\n损失函数\n用于度量模型一次预测的好坏，用于度量预测错误的程度，是f(x)和Y的非负实值函数，L（Y，f(X)）\n常用损失函数\n0-1损失函数\n平方损失函数\n绝对损失函数\n对数损失函数\n\n\n\n\n风险函数（期望损失）\n损失函数的期望\n又要最小化期望损失，联合分布概率又未知，又要学习联合分布概率——&gt;监督学习变成病态问题\n\n\n经验风险（经验损失）\n模型关于训练样本集的平均损失。只要样本足够多，就可以用经验风险去估计期望损失。\n\n\n\n经验风险最小化与结构风险最小化\n什么是经验风险最小化？有什么作用？有什么注意事项？\n经验风险最小化是指是的经验风险或损失达到最小以此保证获得最优模型。\n作用：当样本足够大时，可以保证很好的学习效果。\n极大似然估计就是经验风险最小化的例子。\n\n\n注意：当样本容量小时，会产生”过拟合“现象。\n\n\n什么是结构风险最小化？有什么作用？\n为了防止过拟合提出来的策略。\n结构风险最小化等价于正则化。\n结构风险在经验风险上加上表示模型复杂度的正则化项或者罚项。\n\n\n\n【Notes】\n\n泛函：任意的向量空间到标量的映射。也就是从函数空间到数域的映射。\n\n1.4 模型评估与模型选择概念\n\n训练误差与测试误差\n测试误差具有更好的预测能力\n\n\n过拟合与模型选择\n过拟合：学习选择的模型所包含参数过多，已知数据上预测效果好，但是未知数据上预测很差。\n\n\n\n1.5 正则化与交叉验证正则化\n作用：选择经验风险和结构风险同时较小的模型。保证预测准确的同时模型最简单。\n\n交叉验证\n简单交叉验证\nS折交叉验证\n留一交叉验证\n\n1.6 泛化能力\n泛化能力：对未知数据的预测能力\n泛化误差上限\n含义\n证明\n\n\n\n1.7 生成模型与判别模型生成模型：学习联合概率分布P（X,Y）\n优势：\n\n可以还原出联合概率分布\n收敛速度更快\n存在隐变量时，仍然可以用生成方法学习\n\n判别模型：直接学习决策函数或者条件概率分布\n优势：\n\n学习的准确率更高\n方便对数据进行各种程度上的抽象、定义特征并使用特征，可以简化学习问题\n\n1.8 监督学习应用1.8.1 分类问题\n分类问题包括学习和分类两个过程。\n\nX可以是离散的也可以是连续的\nY取有限个离散值\n\n\n分类性能指标：分类准确率。\n\n二分类问题常用评价指标：\n\n精确率P\n\n召回率R\n\nF1 score： 2&#x2F;F &#x3D; 1&#x2F;P + 1&#x2F;R\n【Notes】：当精确率和召回率都高时，F1也会高\n\n\n\n\n1.8.2 标注问题\n标注问题是分类问题的推广。\n输入：一个观测序列\n输出：一个标记序列或者状态序列\n过程：学习和标注两个过程\n\n\n\n1.8.3 回归问题\n回归问题的学习等价于函数拟合\n常用损失函数：平方损失函数\n使用平方损失函数时，可以用最小二乘法求解\n\n\n\n疑问\n推导经验风险最小化与极大似然估计的关系。日常应用模型需要满足的条件是什么？\n推导贝叶斯估计和结构风险最小化的关系\n泛化误差怎么理解？泛化误差上界有什么应用？怎么证明的？\n\n习题","categories":["机器学习"],"tags":["机器学习","统计学习概论"]},{"title":"概率论基础知识复习","url":"/2022/06/04/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/","content":"博客内容：本文的所有内容为对B站视频（可能是全网最好的《概率统计》期末速成，2小时不到冲刺60分，概率论与数理统计_哔哩哔哩_bilibili）的笔记记录，用于复习概率论的基础知识。\n00:42 概率的性质\n加法公式\n减法公式\n对立事件概率\n分配律\n【Notes】：∩可以当作乘，∪可以当作\nP（（AB）∪C）&#x3D; P（（A∪C）∩（B∪C））\n\n\n对偶律\n\n06:39  条件概率\n条件概率公式\n古典概型\n\n14:20  全概率与贝叶斯公式\n全概率公式：所求A事件可以分成几种情况，把这些情况加起来\n贝叶斯公式：已知A事件发生，求是哪个情况\n\n20:22  事件的独立性\n事件A与事件B独立的概率角度说明\nA与B相互独立，则可以推出什么还相互独立\n\n23:44  离散型随机变量分布律与分布函数互求\n列表看\n分布函数\n性质\n[0,1]之间\n单调不减\n右连续\n\n\n计算\n注意：在端点处存在概率跳跃，以此可以推导某个离散值的概率\n\n\n\n\n\n28:45  二项分布和泊松分布\n二项分布\n做n重伯努利试验（0-1分布）\n二项分布的分布律公式\nX~B（n,p）做了n次实验，每次A发生的概率是p\n期望：np\n方差：np(1-p)\n\n\n\n\n泊松分布\n两个参数\n分布律公式\n\n\n\n31:50  连续型随机变量概率的计算\n分布函数\n定义\n性质（3个）\n\n\n概率密度函数\n定义\n性质（3个）\n\n\n概率求法：求P（X≤a）\n【Notes】：端点取不取不重要\n\n\n\n37:15  均匀分布\n定义\n期望\n方差\n\n38:15  正态分布\n定义\n概率密度函数\nN（0，1）的重要特性\n如何将其他正态分布化为N（0，1）\n\n\n期望\n方差\n\n41:26  离散型随机变量函数的分布\n已知离散型随机变量X的分布，求Y&#x3D;g(X)的分布律和分布函数\n直接算出每个X对应的Y，然后再整合\n\n\n\n42:46  连续型随机变量函数的分布\n已知连续性随机变量X的概率密度函数，求Y&#x3D;g(X)的概率密度函数\n分布函数求法：先求Y的分布函数，再求导\n关键在于求出对应的X的范围，然后在该范围内对X的概率密度函数积分\n\n\n\n\n\n48:13  二维离散型随机变量的分布\n联合分布律\n边缘分布律\n“消去”其中一个参数：相加所有可能情况\n\n\n\n52:20  二维连续型随机变量的分布\n联合分布函数\n联合分布概率密度：负无穷到正无穷积分得到1\n边缘概率密度函数\n分别对某个参数积分消掉\n\n\n条件概率密度\n当X和Y相互独立时，联合概率密度 &#x3D; 边缘概率密度相乘\n\n58:53  二维离散型随机变量函数的分布\n不难，略过\n\n61:38  二维连续型随机变量函数的分布\n求Z &#x3D;g (X,Y)的概率密度函数\n分布函数法：确定积分范围，计算二重积分\n\n\nX,Y相互独立时，Z&#x3D;max(X,Y)和Z&#x3D; min(X,Y)的分布函数\n正态分布可加性\n\n67:22  数学期望\n离散型随机变量期望计算\n连续性随机变量期望计算：积分x*f(x)\n期望的性质\n随机变量加上某个常数\n随机变量乘上某个常数\nE（X+Y） &#x3D; E（X）+ E（Y），无论X，Y是否独立\n\n\n\n70:30  方差和标准差\n方差计算：用期望计算\n标准差\n方差性质\n常数的方差\n随机变量上加上常数\n随机变量乘以常数C：方差需要乘以C²\nD（X±Y）\nX，Y不独立时\nX，Y独立时\n\n\n\n\n\n74:57  常用分布的期望和方差\n0-1分布\n二项分布\n泊松分布\n均匀分布\n正态分布\n指数分布\n\n78:24  协方差和相关系数\n协方差计算：E（XY）-E（X）E（Y）\n协方差性质\n与常数\n变量前乘以某个常数 \n与方差关系\n\n\n相关系数计算：去除量纲的影响\n\n86:10  中心极限定理\n满足独立同分布，每个变量都满足同一个正态分布\n满足独立同分布，每个变量都满足二项分布，当n充分大时，有X~N（np,npq）\n\n92:35  三大分布\n卡方分布\nt分布\nF分布\n\n96:38  矩估计\n计算步骤\n\n99:56  极大似然估计\n写出极大似然函数\n取对数求导\n\n103:04  假设检验\n构造原假设和对立假设\n\n","categories":["机器学习","概率论"],"tags":["概率论基础","机器学习基础"]},{"title":"线性代数-方程组的几何解释及消元","url":"/2022/06/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%9A%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E5%87%A0%E4%BD%95%E8%A7%A3%E9%87%8A%E5%8F%8A%E6%B6%88%E5%85%83/","content":"博客内容：\n\nrow picture&amp;column picture\nelimination\nto solve “Ax &#x3D; b”\nAx is a combs of the columns of A\n\n\ndo the linear combs of the columns fill the space?\nYes for non-singular matrix(invertible matrix)\nNo for singular matrix\n\n\n\n\nregular way&amp; column way&amp; row way\n\n1. Row picture &amp; Column pictureRow picture\n以二元线性方程为例，具有x y 两个未知数，按照普通解法，画出这两条线，找交点即可。\n$$\\begin{cases}   x-2y &#x3D; 0,\\   2x + y &#x3D; 5\\end{cases}$$Column picture\n从列的角度看，求b实际是把A矩阵的列向量进行线性组合，在对应维度的空间里进行向量的加减。\n这里的列向量、A矩阵、b向量、x向量分别为$$column &#x3D; \\begin{bmatrix}1\\2\\end{bmatrix} &amp;\\begin{bmatrix}-1\\1\\end{bmatrix}\n\\A &#x3D; \\begin{bmatrix}1&amp;-1 \\2&amp; 1\\end{bmatrix}\\b &#x3D; \\begin{bmatrix}0 \\5\\end{bmatrix}$$该方程的解为x &#x3D; 2, y &#x3D;1,所以$$x &#x3D; \\begin{bmatrix}2&amp;1\\end{bmatrix}$$可以看作是$$2\\begin{bmatrix}1\\2\\end{bmatrix} + 1 \\begin{bmatrix}-1\\1\\end{bmatrix}$$这就是为什么说可以把Ax看作是A的列向量的线性组合\n2. eliminationAim\n\nlet the postions before the pivot becomes zero\n\nsome concepts\n\npivot 主元\nE21表示对第二行第一列的数字进行消元操作\n\n矩阵的左乘和右乘是有区别的$$[2\\ 1]\\begin{bmatrix}1&amp;2 \\3&amp;4\\end{bmatrix} &#x3D; 2*[1&amp;2] + 1*[3&amp;4]$$左乘表示对行向量进行线性组合，右乘则是对列向量进行线性组合。\n按照这种方法可以快速的写出：\n\n每一步用于消元的矩阵，即初等矩阵Elementary matrix\n用于交换行顺序或者列顺序的矩阵，即置换矩阵permutation matrix\n\n矩阵运算满足结合律\n","categories":["线性代数"],"tags":["消元及行列向量理解","矩阵乘法和逆矩阵","矩阵LU分解"]},{"title":"采用hexo和github搭建个人博客","url":"/2022/05/19/%E9%87%87%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":"参考资料：\n使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)\n1. Hexo安装\n安装Node.js与git\n\n前往官网下载即可，无脑一直continue\n\ncmd打开命令工具，查看安装是否成功\nnode -vnpm -vgit --version \n\n\n安装Hexo\n\n执行安装命令： npm install -g hexo-cli\n\n进入自己想要书写博客的文件夹，此处建立在F盘下的“myblog”文件夹下\nhexo init      # 初始化npm install    # 安装组件hexo g   # 生成页面hexo s   # 启动预览\n\n执行完成访问http://localhost:4000，可以看到自己的博客\n\n\n\n\n2. Github配置\n使用git连接github\n\n在git bash中设置用户名和邮箱，设置完成后会在.ssh下出现.gitconfig文件\ngit config --global user.name &quot;GitHub 用户名&quot;git config --global user.email &quot;GitHub 邮箱&quot;\n\n\n新建github仓库\n\n仓库名称为：用户名.github.io\n设置为public\n\n\n配置hexo的配置文件\n\n编辑“myblog&#x2F;_config.yml”文件，修改文件末尾的deploy为如下设置。\n\n这里采用http连接，不采用ssh连接，因此无需配置ssh。repo后的连接就是http方式，这里填写自己的仓库链接就好。\n\nbranch网络上都给出的是master，但是这里自己实践如果推送到master会显示不了，仓库默认是main，因此这里把branch改成了main，后续也将会把内容都推送到main中。之后就可以正常显示了。\ndeploy:  type: git  repo: https://github.com/naniko7/naniko7.github.io.git  branch: main\n\n\n\n3. hexo主题配置3.1 hexo文件夹说明\n初始化后的部分文件说明\n_config.yml：网站的配置信息\npackage.json：应用程序的信息。比如一些依赖项的版本\nscaffolds ：模板文件夹\nsource：资源文件夹。\n用于存放用户资源，除了_posts文件夹之外，开头命名为  _ 的文件夹或文件以及隐藏文件 将被忽略。\nMarkdown和HTML文件将被解析并放到public文件夹，其他文件会被拷贝过去。\n\n\nthemes：主题文件夹\nHexo会根据主题来生成静态页面\n\n\n\n\n\n:star:一些杂记\n_config.yml\n\n_config.yml使用的是yaml语法，同时也支持json格式，但是json格式相较于yaml更为复杂。\n在模板中如“- - -”的符号改为“; ; ;”就能支持json\n\nlayout\n\n默认有三种布局：post, draft, page。其中draft不会被显示在网页上。\n\n创建新文章的命令为：\nhexo new post “new blog”，这里创建的就是post布局\n如果创建了草稿，并且需要迁移到post中，则需要：\nhexo new draft “new blog”\nhexo publish draft “new blog”\n\n\nScaffold\n\n默认布局是三种，可以自己新建布局，存放scaffolds文件夹中。\n默认的scaffolds中就存放了draft, page, post三个布局的md文件。\n\nFront-matter\n\ncategories参数：分类具有顺序性和层次性\ntags参数：标签没有顺序和层次\ncomment参数：是否开启评论\n\n永久链接\n\n如果需要考虑使用恒定id，确保评论与文章不会映射混乱，可以使用插件hexo-abbrlink。\n\n3.2 hexo主题使用个人使用主题：Keep 配置指南 | hexo-theme-keep (xpoet.cn)\n3.3 hexo命令\nhexo new ： hexo new [layout]   title\n用途：创建不同布局的博客\n可用参数\n-p：定义新文章路径（文件夹位置，非url）\n-r ：存在同名文章时替换\n-s：文章的slug\n\n\n\n\nhexo generate:  简化形式“hexo g”\nhexo publish\nhexo server\nhexo deploy: 简化形式为“hexo d”\nhexo render\nhexo migrate\nhexo clean\n\n3.4 实用操作1. 插入图片\n参考资料： Hexo官网“标签插件—–Embed image”\n\n配置.config.yml以下参数\npost_asset_folder: truemarked:  prependRoot: true  postAsset: true\n\n\n\n两种插入方式\n\n使用标签插件\n说明：使用标签插件是指使用\n&#123;% asset_img img_path img_dis %&#125;\n\n\n\n图片放置位置： 将“post_asset_floder”参数设为true后，会自动生成一个同名的文件夹，将图片放在该文件夹下即可。\n\n直接嵌入\n说明：使用markdown的一般语法，e.g\n![ ]()\n\n\n\n图片放置位置： 将“post_asset_floder”参数设为true后，会自动生成一个同名的文件夹，将图片放在该文件夹下即可。\n\n\n\n\n4. SVG图标一些精彩的动画：30个很棒的SVG动画 - SegmentFault 思否\n图标获取网站：\n\nVector Icons and Stickers - PNG, SVG, EPS, PSD and CSS (flaticon.com)\nAnimate Your Own Icon into GIF &#x2F; loading.io\niconfont-阿里巴巴矢量图标库\n\n","categories":["hexo"],"tags":["hexo","github pages"]}]